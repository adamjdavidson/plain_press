/# Data Model

## Overview

The system tracks articles through their lifecycle, records all feedback, maintains source quality scores, and stores the filtering rules that can be refined over time.

This document describes the conceptual model. Implementation will use PostgreSQL with SQLAlchemy ORM.

---

## Entity: Article

An article is any news story that the system has encountered, whether from RSS feeds or web searches.

### Fields

| Field | Type | Description |
|-------|------|-------------|
| id | UUID | Primary key |
| external_url | String | Original article URL (unique) |
| headline | String | Article headline as found |
| source_name | String | Publication name (e.g., "UPI Odd News") |
| source_id | FK → Source | Reference to source entity |
| published_date | DateTime | When the article was published |
| discovered_date | DateTime | When our system found it |
| summary | Text | 2-3 sentence summary (generated by AI during filtering) |
| amish_angle | Text | Why this might work for Amish readers (AI-generated) |
| filter_score | Float | AI confidence score (0-1) that this passes criteria |
| filter_notes | Text | AI reasoning about why included/borderline |
| raw_content | Text | Full article text if available |
| emailed_date | DateTime | When included in daily email (null if not yet sent) |
| email_batch_id | FK → EmailBatch | Which daily email included this |
| status | Enum | pending, emailed, good, rejected, passed |
| google_doc_id | String | Google Doc ID if "Good" (null otherwise) |
| google_doc_url | String | Google Doc URL if "Good" |
| created_at | DateTime | Record creation timestamp |
| updated_at | DateTime | Last update timestamp |

### Status Values

- **pending**: Discovered but not yet emailed
- **emailed**: Included in daily email, awaiting rating
- **good**: Marked as Good, deep dive generated
- **rejected**: Marked as No or Why Not
- **passed**: Was Good, but ultimately not used for publication

### Notes

- `external_url` is unique to prevent duplicate processing
- Articles remain in database forever for pattern analysis
- `filter_score` and `filter_notes` help debug filtering quality

---

## Entity: Source

A source is a publication, RSS feed, or search query pattern that produces articles.

### Fields

| Field | Type | Description |
|-------|------|-------------|
| id | UUID | Primary key |
| name | String | Human-readable name (e.g., "UPI Odd News") |
| type | Enum | rss, search_query, manual |
| url | String | RSS feed URL or base URL for search |
| search_query | String | For search_query type, the query pattern |
| is_active | Boolean | Whether to include in daily searches |
| trust_score | Float | 0-1 score based on approval rate |
| total_surfaced | Integer | Count of articles found from this source |
| total_approved | Integer | Count of "Good" articles |
| total_rejected | Integer | Count of "No" or "Why Not" articles |
| last_fetched | DateTime | When we last pulled from this source |
| notes | Text | Editor notes about this source |
| created_at | DateTime | Record creation timestamp |
| updated_at | DateTime | Last update timestamp |

### Type Values

- **rss**: Standard RSS feed, fetched via feedparser
- **search_query**: Exa API search with specific query pattern
- **manual**: Manually added articles (future feature)

### Trust Score Calculation

```
trust_score = total_approved / (total_approved + total_rejected)
```

If `total_approved + total_rejected < 10`, use default score of 0.5 (not enough data).

---

## Entity: Feedback

Feedback records every rating decision Adam makes, including optional explanatory notes.

### Fields

| Field | Type | Description |
|-------|------|-------------|
| id | UUID | Primary key |
| article_id | FK → Article | Which article this feedback is about |
| rating | Enum | good, no, why_not |
| notes | Text | Editor's explanation (especially for why_not) |
| clicked_at | DateTime | When the button was clicked |
| created_at | DateTime | Record creation timestamp |

### Rating Values

- **good**: Article approved, triggers deep dive
- **no**: Article rejected, no explanation
- **why_not**: Article rejected with explanation

### Notes

- One article can have only one feedback record (enforce in code)
- `notes` is typically null for "good" and "no", populated for "why_not"

---

## Entity: FilterRule

Filter rules are the current criteria the AI uses to evaluate articles. These can be edited by Adam and evolve over time based on feedback.

### Fields

| Field | Type | Description |
|-------|------|-------------|
| id | UUID | Primary key |
| rule_type | Enum | must_have, must_avoid, good_topic, borderline |
| rule_text | Text | The actual rule statement |
| priority | Integer | Order of importance (lower = more important) |
| is_active | Boolean | Whether this rule is currently applied |
| source | Enum | original, learned, manual |
| learned_from_count | Integer | How many feedback items suggested this rule |
| created_at | DateTime | When this rule was created |
| updated_at | DateTime | Last update |

### Rule Type Values

- **must_have**: Required qualities (e.g., "must be wholesome")
- **must_avoid**: Disqualifying content (e.g., "no death or tragedy")
- **good_topic**: Topic categories that work well (e.g., "animals")
- **borderline**: Cases requiring judgment (e.g., "individual craftsman stories")

### Source Values

- **original**: From the initial story_criteria.md
- **learned**: Suggested by weekly refinement analysis
- **manual**: Added directly by Adam

---

## Entity: EmailBatch

Tracks each daily email sent, for debugging and analysis.

### Fields

| Field | Type | Description |
|-------|------|-------------|
| id | UUID | Primary key |
| sent_at | DateTime | When the email was sent |
| recipient_emails | String[] | List of recipients |
| article_count | Integer | How many articles included |
| subject_line | String | Email subject |
| status | Enum | sent, failed |
| error_message | Text | If failed, why |
| created_at | DateTime | Record creation timestamp |

---

## Entity: DeepDive

Records generated deep dive reports for "Good" articles.

### Fields

| Field | Type | Description |
|-------|------|-------------|
| id | UUID | Primary key |
| article_id | FK → Article | Which article this report is for |
| headline_suggestion | String | AI-suggested headline |
| key_points | Text[] | Array of key points/themes |
| additional_sources | JSONB | Array of {url, title, description} |
| full_report_text | Text | Complete report as generated |
| google_doc_id | String | Created Google Doc ID |
| google_doc_url | String | Created Google Doc URL |
| google_sheet_row | Integer | Row number in tracking spreadsheet |
| generated_at | DateTime | When the report was generated |
| email_sent_at | DateTime | When report email was sent |
| created_at | DateTime | Record creation timestamp |

---

## Entity: RefinementLog

Tracks weekly refinement suggestions and whether they were accepted.

### Fields

| Field | Type | Description |
|-------|------|-------------|
| id | UUID | Primary key |
| week_start | Date | Monday of the week analyzed |
| week_end | Date | Sunday of the week analyzed |
| total_articles_reviewed | Integer | How many articles Adam rated that week |
| total_good | Integer | Count of "Good" ratings |
| total_no | Integer | Count of "No" ratings |
| total_why_not | Integer | Count of "Why Not" ratings |
| suggestions | JSONB | Array of suggested changes |
| accepted_suggestions | JSONB | Which suggestions Adam accepted |
| created_at | DateTime | Record creation timestamp |

### Suggestions Structure

```json
{
  "suggestions": [
    {
      "type": "add_rule",
      "rule_type": "must_avoid",
      "rule_text": "Avoid stories focused on social media influencers",
      "evidence": "3 rejections this week mentioned influencer content",
      "accepted": true
    },
    {
      "type": "adjust_source",
      "source_id": "uuid-here",
      "source_name": "Good News Network",
      "current_trust_score": 0.3,
      "suggested_action": "deprioritize",
      "reason": "8 rejections, 2 approvals this week",
      "accepted": false
    }
  ]
}
```

---

## Relationships Diagram

```
┌─────────────┐       ┌─────────────┐
│   Source    │───────│   Article   │
└─────────────┘ 1:N   └─────────────┘
                            │
                            │ 1:1
                            ▼
                      ┌─────────────┐
                      │  Feedback   │
                      └─────────────┘
                      
                      ┌─────────────┐
                      │  DeepDive   │
                      └─────────────┘
                            │
                            │ 1:1
                            ▼
                      ┌─────────────┐
                      │   Article   │
                      └─────────────┘

┌─────────────┐       ┌─────────────┐
│ EmailBatch  │───────│   Article   │
└─────────────┘ 1:N   └─────────────┘

┌─────────────┐
│ FilterRule  │  (standalone, referenced by filtering logic)
└─────────────┘

┌───────────────┐
│ RefinementLog │  (standalone, weekly snapshots)
└───────────────┘
```

---

## Indexes

For performance, index:

- `articles.external_url` (unique, for deduplication)
- `articles.status` (filtering pending/emailed)
- `articles.discovered_date` (sorting)
- `articles.source_id` (source performance analysis)
- `feedback.article_id` (lookup)
- `feedback.rating` (analysis)
- `feedback.clicked_at` (weekly analysis)
- `sources.is_active` (daily job filtering)

---

## Data Retention

- **Articles**: Keep forever (disk is cheap, history is valuable)
- **Feedback**: Keep forever (essential for learning)
- **EmailBatch**: Keep 1 year, then archive
- **FilterRules**: Keep forever, track history via updated_at
- **RefinementLog**: Keep forever (weekly snapshots are small)
- **DeepDive**: Keep forever (linked to articles)

---

## Sample Queries

### Get articles for daily email
```sql
SELECT * FROM articles 
WHERE status = 'pending' 
AND filter_score > 0.5
ORDER BY filter_score DESC, discovered_date DESC
LIMIT 50;
```

### Calculate source trust score
```sql
SELECT 
  s.name,
  s.total_approved,
  s.total_rejected,
  CASE 
    WHEN (s.total_approved + s.total_rejected) < 10 THEN 0.5
    ELSE s.total_approved::float / (s.total_approved + s.total_rejected)
  END as trust_score
FROM sources s
WHERE s.is_active = true
ORDER BY trust_score DESC;
```

### Get this week's feedback for refinement
```sql
SELECT 
  f.rating,
  f.notes,
  a.headline,
  a.source_name,
  a.amish_angle
FROM feedback f
JOIN articles a ON f.article_id = a.id
WHERE f.clicked_at >= date_trunc('week', now())
ORDER BY f.clicked_at;
```

### Find rejection patterns
```sql
SELECT 
  f.notes,
  COUNT(*) as count
FROM feedback f
WHERE f.rating = 'why_not'
AND f.notes IS NOT NULL
AND f.clicked_at >= now() - interval '30 days'
GROUP BY f.notes
ORDER BY count DESC;
```
